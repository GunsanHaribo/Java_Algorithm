#### 타입소거 (TYPE Erasure) => boxed, 리플렉션, 
리플렉션에 대한 이해를 기본으로 하는 것 같다 
제네릭 타입정보가 컴파일 시점에는 존재하지만, 런타임 시점에서는 제거가 된다 


컴파일 시점에서는 타입을 알 수 있지만 
런타임에 들어가면 T가 Object로 처리가 된다.... 이유는 모르겠음 
List<Integer>, List<String>이 단순히 List로 처리된다 

제네릭이나 Comparator에서는 왜 boxed된 타입을 사용하는 거지?
=> 타입 소거의 특성으로 원시타입데이터를 사용할 수 없다는데 이유가 뭐지 : 기본형 object로 변환불가

자바에서는 제네릭 클래스나 인터페이스 배열을 선언하지 못한다 => 이 내용 모르겠음 

1. 호환성 유지 : 새로운 제너릭 코드가 기존의 비제네릭 코드와 잘 동작하도록 
   1. 제네릭사용하면 호환성을 어떻게 보장한거지? 기존에 List로 들어갔던거 똑같이 List로 사용할 수 있도록? 
   2. List myList = new ArrayList(); 이런거사용 
   3. ##### 등장이유 : 타입안정성 => 이게 왜 필요한데 
   4. 브릿지 메서드는 뭔데 - 오버라이딩 용? 
2. 성능 최적화 : 타입정보 유지하지 않으므로서 실행성능유지 => 이유? 

브리지 메서드 삽입: 제네릭이 도입되면서 오버라이딩 관계가 복잡해질 수 있습니다. 
예를 들어, 제네릭 클래스에서 상속받은 메서드를 오버라이드할 때, 컴파일러는 원래 메서드와 동일한 시그니처를 가진 "브리지 메서드"를 자동으로 생성하여 타입 캐스팅을 수행합니다. 
이는 런타임에 다형성을 올바르게 지원하기 위해 필요합니다.


구현은 알겠는데 기술 개념을 익힐때 어ㄴ방식으로 익힐지 생각해야된다 
질문을 통한 건 알겠다 => drilldown 그런데 어떤게 좋은 코드인데?
키워드위주 학습도 알겠다 