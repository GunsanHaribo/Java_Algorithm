## 요구사항 : 6번째 과제로 친구를 추천하는 기능을 개발
1. 친구를 추천하고자 하는 사용자의 친구 목록과 친구가 아닌 다른 사용자의 친구 목록을 비교하여 "함께 아는" 친구의 수를 계산
2. 함께 아는 친구의 수가 가장 많은 순서로 최대 5명을 추천한다
3. 함께 아는 친구의 수가 같은 경우 사용자 ID가 작은 값을 가지는 사용자를 우선한다
4. 친구를 추천하고자 하는 사용자와 함께 아는 친구가 없는 사용자는 친구 추천에서 제외한다

함수 
1. init -> 테스크 케이스 초가화
2. add -> 사용자 id 가 id인 사용자는 "ids"로 주어진 F명의 사용자들과 서로 친구가 된다
3. del -> id1인 사용자와 사용자 id가 id2인 사용자가 더이상 서로 친구가 되지 않는다 
4. recommend -> 사용자 id가 id인 사용자에게 친구 추천을 한다. 추천되는 id는 우선 순위에 대한 내림차순으로 list 배열에 저장된다 

=> 친구목록을 추천해서 개인의 친구를 추가하거나 삭제해라 근데... ids는 뭐냐?, list 하고 다른데 
## 도메인
1. 객체, 관계
   1.  사용자들 
   2. 관계 ids들
2. 자료구조
   1. 사용자 : 친구목록 -> HashMap 사용, 인접 리스트 처럼 해도 됩니다 -> 생각해보니깐 이게 더 좋은 수도
   2. 서로 얽혀있으니깐 인접리스트사용
## 흐름
1. init : 초가화 => 1번 
2. add : id를 기준으로 ids랑 clsrn  => 2번 
3. del : id두개에서 서로 친구 목록 삭제  => 3번 
4. recommend : 해당 id가 친구등록이 안된 친구 중에서 등록된 친구 중에 가장 인구 수가 많은 것 => 4번

input 
첫번째 : 1 100 -> ?
두번째 : 20 줄 받는다 
세번재 1(init) -> 8

output 
#1 100 이 뭐지? 
그 solution 코드는 건들면 안됨 
user solution 만 수정



# 문제점 

remove(object) -> Integer.value()  => 아니면 인덱스로감 
answerLength -> 마지막에 5넘으면 list사이즈로 해야됩니다 

# CallbyValue 문제 
Java에서 메소드 매개변수로 받은 List를 다른 List로 덮어쓰는 것은 불가능합니다. 이는 Java의 메소드가 매개변수를 호출할 때 참조를 복사하여 전달하기 때문입니다. 따라서 메소드 내부에서 매개변수로 받은 List의 참조를 변경해도, 메소드 외부에서는 그 변경 사항이 반영되지 않습니다.
그니깐 내부 요소 수정을 같은 주소를 참고해서 반영이 되는데 
아예 다른 배엿 list(매개변수) = listB로 하려고 하면 안된다는거네
참조값을 복사해서 매개변수에 넣어서 들어가지 그니깐 안에 매개변수에 이상한거 할당해도 밖에 list 변수는 아무런 영향이 없다 

### 할당후
Stack Frame: modifyList
Variables:
- list = (ArrayList) [4, 5, 6]

Stack Frame: main
Variables:
- originalList = (ArrayList) [1, 2, 3]

### 종료후 
Stack Frame: main
Variables:
- originalList = (ArrayList) [1, 2, 3]

## 중복체크가 필요하다면(contain사용시) 할 필요없이 Set을 사용하자 
## 그리고 Set은 hash 사용해서 contain 속도가 list보다 훨씬 빠르다 
## 둘 중 최솟값 선택해야될떄 