## 요구사항  : 5 × 5 크기의 초기 퍼즐의 상태와 퍼즐 중앙에 맞춰야 할 3 × 3 크기의 패턴이 주어질 때, 주어진 패턴이 중앙에 있을 수 있도록 퍼즐을 맞추어라.
1. 지금의 나는 얼마나 효과적으로 퍼즐을 맞출 수 있을까? - swap의 호출 횟수가 적을수록 효율적이다 
2. 퍼즐은 5*5 크기의 공간에 24개의 블록과 한칸의 빈칸이 있다 
3. 빈칸을 이용해서 한번에 하나의 블록만 움직일 수 있다 
4. 블록의 위치를 바꿀 수 있는 API가 주어진다 -swap 상하좌우 
5. 3*3 크기의 패턴이 주어질때 퍼즐 중앙에 주어진 패턴을 만들어야 한다 
6. 단 swap API의 호출 횟수가 callCntLimit보다 적도록 구현하라 

함수 
1. solve
   1. swap를 callCnt보다 적은 횟수로 호출하여 패턴이 중앙에 있도록 퍼즐을 맞춘다 

2. swap : 빈칸을 기준으로 움직인다 
   1. 빈칸과 dir에 위치한 블록의 위치를 바꾼다 -> dir 은 0~3
   2. 빈칸을 기준으로 왼쪽꺼랑 바꾸면 좌, 위에꺼로 바꾸면 상,, 상하좌우가 있음 

## 도메인 
1. 개념, 관계 
   1. 큐브와 블록들
2. 자료구조
   1. 큐브 좌표 - 배열, 큐

## 흐름 : 빈칸을 이동시켜서 블록이 목표지점까지 가게하기 
1. solve에서 특정 규칙이나 방법에 의해서 3*3을 뽑아내야된다
2. solve는 언제 끝내지? -> pattern하고 맞으면 종료한다 
3. 패턴 맞추기 2가지 함수 
   1. 3*3 패턴에 있는 블록 중 하나와 같은 색상을 찾는 함수 -> input : pattern, board // ouput : 최단 거리 경로 
      1. 패턴을 기준으로 -> 현재좌표에서 가야될 좌표까지의 거리를 구한다, 거리중에서 가장 가까운 곳에 있는거 찾는다?(최단거리) 
         1. 패턴중 정해지지 않은 부분을 하나(k) 고른다 -> for문 돌면서 y=0 x=(0,1,2), y=1 x=(0,1,2)
         2. 움직일 블록을 찾으면서 길을 찾는걸 BFS로 한번에 한다 
            1. 움직일 블록(i)을 찾는다 
               1. 패턴(k)에 맞는 색깔 중 하나를 최단거리에 있는 애중에 고른다 : 그냥 아무거나 고른다- 고민하지 말자 
               2. 최단 거리(BFS) 사용하면 2초안에 끝날 수가 없어
            2. 패턴(k) 사이 움직일 길을 찾는다 : pattern에서 fixed된 부분은 건들지 않는다 ==> 장매물이 되어버림 
               1. 길 저장하는게 좋을 듯  -> 첫번째 두번쨰 세번째 : 최종 역순으로 저장 
         3. 클래스를 사용해서 좌표와 경로를 저장해 놓는다 => input, PriorityQueue
            1. 패턴과 블록 사이의 거리를 ArrayList로 해서 저장한다 : 미리 갯수를 알고 있으면 좋겠지 
   2. 빈칸이 길의 요소들로 가는 경로 구한다 다시한번 :  길의 첫번째 두번째 부분으로 가는 빈칸의 최단 거리를 구한다 -> input 3의 과정에서 최단거리 경로 리스트 원소 중 하나
      1. BFS 템플릿을 다시 사용한다 => 길까지 가는 경로를 구한다 
      2. 여기서 근데 fixed된 부분은 장애물로 피해간다
   3. 경로를 통해서 이동한다 swap 사용해야된다 
      1. 근데... swap을 어떻게... 이게 BFS를 구하면서 계속 바뀌어야 되는 것 같기도 한데 
      2. 이게 left로 갈지 아니면 다른 데로 갈지 어떻게 알아 이새키야 -> 재활용하자 
      3. board를 어떻게 할건데?
      4. 최단 거리를 잡으면? 그니깐 swap을 어떻게 할건지 생각해야된다
5. 경고 : 한번 맞는 자리를 찾아가면 그 자리는 건들지 않도록한다 
   1. 건들수 밖에 없으면 어떻게 하지? : 최대한 fixed되면 돌아가는걸로한다 
6. 이게 블록 수 만큼 4가지 경우를 할 수 도 있긴한데 2초안에 그게 가능할지는 모르겠다 일단 최단 거리 부터하고 시간이 남으면 가능한 경웅의 수를 모두 세보는 걸로 하자 


/

## 다시 적는 흐름  y,x로 통일 



큐로하면 무조건 최소인가? => 생각해보니깐 또 맞긴해 
// 이거 패턴은 기억하고 있어야된다 pattern은 기억하고 있어야됨 
// board는 바뀌어도 되는데 

// 여기서 이게 맞나? // 또 전체 board하고 조금 달라서 약간식 처리 해줘야 된다


// 그러면 여기서 board가 바귄채로 유지가 안될 수도 있는데 이건 어떻게 관리하지? 

// 그니깐 지금 패턴은 안바뀌어도 board는 계속 바뀌거든 